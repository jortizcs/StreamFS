<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.4.2) on Thu Sep 01 06:58:35 EDT 2005 -->
<TITLE>
IntegerDijkstraTemplate (Docs for JDSL 2.1.1)
</TITLE>

<META NAME="keywords" CONTENT="jdsl.graph.algo.IntegerDijkstraTemplate class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="IntegerDijkstraTemplate (Docs for JDSL 2.1.1)";
}
</SCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../jdsl/graph/algo/IntegerDijkstraPathfinder.html" title="class in jdsl.graph.algo"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../jdsl/graph/algo/IntegerPrimTemplate.html" title="class in jdsl.graph.algo"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="IntegerDijkstraTemplate.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
jdsl.graph.algo</FONT>
<BR>
Class IntegerDijkstraTemplate</H2>
<PRE>
<A HREF="http://java.sun.com/j2se/1.4/docs/api/java/lang/Object.html" title="class or interface in java.lang">java.lang.Object</A>
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by"><B>jdsl.graph.algo.IntegerDijkstraTemplate</B>
</PRE>
<DL>
<DT><B>Direct Known Subclasses:</B> <DD><A HREF="../../../jdsl/graph/algo/IntegerDijkstraPathfinder.html" title="class in jdsl.graph.algo">IntegerDijkstraPathfinder</A></DD>
</DL>
<HR>
<DL>
<DT>public abstract class <B>IntegerDijkstraTemplate</B><DT>extends <A HREF="http://java.sun.com/j2se/1.4/docs/api/java/lang/Object.html" title="class or interface in java.lang">Object</A></DL>

<P>
Implementation of Dijkstra's algorithm using the template-method
 pattern: the core functionality is coded in a few final methods
 that call overridable methods to do some of the work.  The methods
 of this class are in five categories:

 <ul>
 
 <li>A method you must override to make the compiler happy: You must
 override weight(Edge) to supply the algorithm with a weight for
 every edge in the graph.  Note that Dijkstra's algorithm cannot
 handle negative-weight edges.
 
 <li>"Hook" methods that may be overridden to specialize the
 algorithm to the application at hand: shortestPathFound(.),
 edgeRelaxed(.), and vertexNotReachable(.).  For every vertex in the
 graph (or every vertex you allow the algorithm to consider), either
 shortestPathFound(.) or vertexNotReachable(.) will be called, and
 will be called exactly once.  When that has occurred, the vertex is
 considered to be "finished"; it will not be considered again by the
 algorithm.  Finally, edgeRelaxed(.) will be called every time an
 edge to an unfinished vertex is explored.
 
 <li>Overridable methods that will need to be overridden more
 rarely: See the comments for shouldContinue(), isFinished(.),
 setLocator(.), getLocator(.), setEdgeToParent(.), newPQ(),
 initMap(), incidentEdges(.), destination(.), vertices(), and
 init(.) (which has a split role between this category of methods
 and the next).

 <li>"Output" methods through which the user can test, after the
 execution of the algorithm, whether a vertex is reachable from the
 source, and retrieve the decorations of the vertices: See the
 comments for isReachable(.), distance(.), and getEdgeToParent(.).
 
 <li>Methods composing the core of the algorithm, which cannot be
 overridden (or, in the case of init(.), should rarely be
 overridden): You can run the algorithm in either of two ways.  If
 you want to run the whole algorithm at once, use either version of
 executeAll(.).  It will call doOneIteration() multiple times, and
 doOneIteration() will call your overridden output methods as it
 encounters vertices.  Instead of using executeAll(.), you can
 single-step the algorithm by calling init(.) to initialize, then
 calling doOneIteration() repeatedly.

 </ul>
 
 Note that it is possible to confuse the algorithm by doing things
 like modifying the graph, messing with the priority queue, or
 changing edge weights while it is running.
<P>

<P>
<DL>
<DT><B>Version:</B></DT>
  <DD>JDSL 2.1.1</DD>
<DT><B>Author:</B></DT>
  <DD>Mark Handy, Galina Shubina, Luca Vismara</DD>
</DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Field Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../jdsl/graph/api/InspectableGraph.html" title="interface in jdsl.graph.api">InspectableGraph</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../jdsl/graph/algo/IntegerDijkstraTemplate.html#g_">g_</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../jdsl/core/api/PriorityQueue.html" title="interface in jdsl.core.api">PriorityQueue</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../jdsl/graph/algo/IntegerDijkstraTemplate.html#pq_">pq_</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../jdsl/graph/api/Vertex.html" title="interface in jdsl.graph.api">Vertex</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../jdsl/graph/algo/IntegerDijkstraTemplate.html#source_">source_</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../jdsl/graph/algo/IntegerDijkstraTemplate.html#IntegerDijkstraTemplate()">IntegerDijkstraTemplate</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../jdsl/graph/algo/IntegerDijkstraTemplate.html#cleanup()">cleanup</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes the decorations from the vertices.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../jdsl/graph/api/Vertex.html" title="interface in jdsl.graph.api">Vertex</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../jdsl/graph/algo/IntegerDijkstraTemplate.html#destination(jdsl.graph.api.Vertex, jdsl.graph.api.Edge)">destination</A></B>(<A HREF="../../../jdsl/graph/api/Vertex.html" title="interface in jdsl.graph.api">Vertex</A>&nbsp;origin,
            <A HREF="../../../jdsl/graph/api/Edge.html" title="interface in jdsl.graph.api">Edge</A>&nbsp;e)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Can be overridden to supply the destination of an edge, although I
 can't think of any reason to do so.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../jdsl/graph/algo/IntegerDijkstraTemplate.html#distance(jdsl.graph.api.Vertex)">distance</A></B>(<A HREF="../../../jdsl/graph/api/Vertex.html" title="interface in jdsl.graph.api">Vertex</A>&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the distance of a vertex from the source.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../jdsl/graph/algo/IntegerDijkstraTemplate.html#doOneIteration()">doOneIteration</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Can be called manually to single-step the algorithm, but you must
 call init(.) before the first call to this method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../jdsl/graph/algo/IntegerDijkstraTemplate.html#edgeRelaxed(jdsl.graph.api.Vertex, int, jdsl.graph.api.Edge, int, jdsl.graph.api.Vertex, int)">edgeRelaxed</A></B>(<A HREF="../../../jdsl/graph/api/Vertex.html" title="interface in jdsl.graph.api">Vertex</A>&nbsp;u,
            int&nbsp;uDist,
            <A HREF="../../../jdsl/graph/api/Edge.html" title="interface in jdsl.graph.api">Edge</A>&nbsp;uv,
            int&nbsp;uvWeight,
            <A HREF="../../../jdsl/graph/api/Vertex.html" title="interface in jdsl.graph.api">Vertex</A>&nbsp;v,
            int&nbsp;vDist)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Can be overridden in any application where the edges considered
 for the shortest-path tree matter.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../jdsl/graph/algo/IntegerDijkstraTemplate.html#execute(jdsl.graph.api.InspectableGraph, jdsl.graph.api.Vertex)">execute</A></B>(<A HREF="../../../jdsl/graph/api/InspectableGraph.html" title="interface in jdsl.graph.api">InspectableGraph</A>&nbsp;g,
        <A HREF="../../../jdsl/graph/api/Vertex.html" title="interface in jdsl.graph.api">Vertex</A>&nbsp;source)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The easiest way to use the algorithm is to use this method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../jdsl/graph/api/Edge.html" title="interface in jdsl.graph.api">Edge</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../jdsl/graph/algo/IntegerDijkstraTemplate.html#getEdgeToParent(jdsl.graph.api.Vertex)">getEdgeToParent</A></B>(<A HREF="../../../jdsl/graph/api/Vertex.html" title="interface in jdsl.graph.api">Vertex</A>&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Can be overridden to supply a way of storing and retrieving one
 edge per vertex.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../jdsl/core/api/Locator.html" title="interface in jdsl.core.api">Locator</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../jdsl/graph/algo/IntegerDijkstraTemplate.html#getLocator(jdsl.graph.api.Vertex)">getLocator</A></B>(<A HREF="../../../jdsl/graph/api/Vertex.html" title="interface in jdsl.graph.api">Vertex</A>&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Can be overridden to supply a way of storing and retrieving one
 locator per vertex.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../jdsl/graph/api/EdgeIterator.html" title="interface in jdsl.graph.api">EdgeIterator</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../jdsl/graph/algo/IntegerDijkstraTemplate.html#incidentEdges(jdsl.graph.api.Vertex)">incidentEdges</A></B>(<A HREF="../../../jdsl/graph/api/Vertex.html" title="interface in jdsl.graph.api">Vertex</A>&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Can be overridden in any application where the default choice of
 edges to consider at any vertex is not satisfactory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../jdsl/graph/algo/IntegerDijkstraTemplate.html#init(jdsl.graph.api.InspectableGraph, jdsl.graph.api.Vertex)">init</A></B>(<A HREF="../../../jdsl/graph/api/InspectableGraph.html" title="interface in jdsl.graph.api">InspectableGraph</A>&nbsp;g,
     <A HREF="../../../jdsl/graph/api/Vertex.html" title="interface in jdsl.graph.api">Vertex</A>&nbsp;source)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Called automatically by executeAll(); must be called by the client
 prior to the first call to doOneIteration() if finer-grained
 control of the algorithm is needed.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../jdsl/graph/algo/IntegerDijkstraTemplate.html#initMap()">initMap</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Can be overridden to initialize a locator-lookup data structure
 of your choosing, but the default implementation, which decorates
 each vertex with its locator, is probably sufficient for most
 purposes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../jdsl/graph/algo/IntegerDijkstraTemplate.html#isFinished(jdsl.graph.api.Vertex)">isFinished</A></B>(<A HREF="../../../jdsl/graph/api/Vertex.html" title="interface in jdsl.graph.api">Vertex</A>&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tests whether a vertex has been reached.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../jdsl/graph/algo/IntegerDijkstraTemplate.html#isReachable(jdsl.graph.api.Vertex)">isReachable</A></B>(<A HREF="../../../jdsl/graph/api/Vertex.html" title="interface in jdsl.graph.api">Vertex</A>&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tests whether a vertex is reachable from the source.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../jdsl/core/api/PriorityQueue.html" title="interface in jdsl.core.api">PriorityQueue</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../jdsl/graph/algo/IntegerDijkstraTemplate.html#newPQ()">newPQ</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Can be overridden to supply a priority queue of your
 choosing, but the default implementation, which gives an empty   
 jdsl.core.ref.ArrayHeap, is probably sufficient for most
 purposes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../jdsl/graph/algo/IntegerDijkstraTemplate.html#runUntil()">runUntil</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Repeatedly calls method doOneIteration() until either the
 priority queue is empty or method shouldContinue() returns false.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../jdsl/graph/algo/IntegerDijkstraTemplate.html#setEdgeToParent(jdsl.graph.api.Vertex, jdsl.graph.api.Edge)">setEdgeToParent</A></B>(<A HREF="../../../jdsl/graph/api/Vertex.html" title="interface in jdsl.graph.api">Vertex</A>&nbsp;v,
                <A HREF="../../../jdsl/graph/api/Edge.html" title="interface in jdsl.graph.api">Edge</A>&nbsp;vEdge)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Can be overridden to supply a way of storing and retrieving one
 edge per vertex.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../jdsl/graph/algo/IntegerDijkstraTemplate.html#setLocator(jdsl.graph.api.Vertex, jdsl.core.api.Locator)">setLocator</A></B>(<A HREF="../../../jdsl/graph/api/Vertex.html" title="interface in jdsl.graph.api">Vertex</A>&nbsp;v,
           <A HREF="../../../jdsl/core/api/Locator.html" title="interface in jdsl.core.api">Locator</A>&nbsp;vLoc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Can be overridden to supply a way of storing and retrieving one
 locator per vertex.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../jdsl/graph/algo/IntegerDijkstraTemplate.html#shortestPathFound(jdsl.graph.api.Vertex, int)">shortestPathFound</A></B>(<A HREF="../../../jdsl/graph/api/Vertex.html" title="interface in jdsl.graph.api">Vertex</A>&nbsp;v,
                  int&nbsp;vDist)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Can be overridden to give you a notification when the shortest
 path to a vertex is determined.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../jdsl/graph/algo/IntegerDijkstraTemplate.html#shouldContinue()">shouldContinue</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Can be overridden in any application where the full shortest-path
 tree is not needed and the algorithm should terminate early.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../jdsl/graph/algo/IntegerDijkstraTemplate.html#vertexNotReachable(jdsl.graph.api.Vertex)">vertexNotReachable</A></B>(<A HREF="../../../jdsl/graph/api/Vertex.html" title="interface in jdsl.graph.api">Vertex</A>&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Can be overridden in any application that involves unreachable
 vertices.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../jdsl/graph/api/VertexIterator.html" title="interface in jdsl.graph.api">VertexIterator</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../jdsl/graph/algo/IntegerDijkstraTemplate.html#vertices()">vertices</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Can be overridden to consider a subset of the vertices in the
 graph, although I can't think of any reason to do so.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected abstract &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../jdsl/graph/algo/IntegerDijkstraTemplate.html#weight(jdsl.graph.api.Edge)">weight</A></B>(<A HREF="../../../jdsl/graph/api/Edge.html" title="interface in jdsl.graph.api">Edge</A>&nbsp;e)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Must be overridden to supply a way of getting a positive weight
 for every edge in the graph.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.lang.<A HREF="http://java.sun.com/j2se/1.4/docs/api/java/lang/Object.html" title="class or interface in java.lang">Object</A></B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="http://java.sun.com/j2se/1.4/docs/api/java/lang/Object.html#clone()" title="class or interface in java.lang">clone</A>, <A HREF="http://java.sun.com/j2se/1.4/docs/api/java/lang/Object.html#equals(java.lang.Object)" title="class or interface in java.lang">equals</A>, <A HREF="http://java.sun.com/j2se/1.4/docs/api/java/lang/Object.html#finalize()" title="class or interface in java.lang">finalize</A>, <A HREF="http://java.sun.com/j2se/1.4/docs/api/java/lang/Object.html#getClass()" title="class or interface in java.lang">getClass</A>, <A HREF="http://java.sun.com/j2se/1.4/docs/api/java/lang/Object.html#hashCode()" title="class or interface in java.lang">hashCode</A>, <A HREF="http://java.sun.com/j2se/1.4/docs/api/java/lang/Object.html#notify()" title="class or interface in java.lang">notify</A>, <A HREF="http://java.sun.com/j2se/1.4/docs/api/java/lang/Object.html#notifyAll()" title="class or interface in java.lang">notifyAll</A>, <A HREF="http://java.sun.com/j2se/1.4/docs/api/java/lang/Object.html#toString()" title="class or interface in java.lang">toString</A>, <A HREF="http://java.sun.com/j2se/1.4/docs/api/java/lang/Object.html#wait()" title="class or interface in java.lang">wait</A>, <A HREF="http://java.sun.com/j2se/1.4/docs/api/java/lang/Object.html#wait(long)" title="class or interface in java.lang">wait</A>, <A HREF="http://java.sun.com/j2se/1.4/docs/api/java/lang/Object.html#wait(long, int)" title="class or interface in java.lang">wait</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Field Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="pq_"><!-- --></A><H3>
pq_</H3>
<PRE>
protected <A HREF="../../../jdsl/core/api/PriorityQueue.html" title="interface in jdsl.core.api">PriorityQueue</A> <B>pq_</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="g_"><!-- --></A><H3>
g_</H3>
<PRE>
protected <A HREF="../../../jdsl/graph/api/InspectableGraph.html" title="interface in jdsl.graph.api">InspectableGraph</A> <B>g_</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="source_"><!-- --></A><H3>
source_</H3>
<PRE>
protected <A HREF="../../../jdsl/graph/api/Vertex.html" title="interface in jdsl.graph.api">Vertex</A> <B>source_</B></PRE>
<DL>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="IntegerDijkstraTemplate()"><!-- --></A><H3>
IntegerDijkstraTemplate</H3>
<PRE>
public <B>IntegerDijkstraTemplate</B>()</PRE>
<DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="weight(jdsl.graph.api.Edge)"><!-- --></A><H3>
weight</H3>
<PRE>
protected abstract int <B>weight</B>(<A HREF="../../../jdsl/graph/api/Edge.html" title="interface in jdsl.graph.api">Edge</A>&nbsp;e)</PRE>
<DL>
<DD>Must be overridden to supply a way of getting a positive weight
 for every edge in the graph.  This method gets called by the
 algorithm when the algorithm needs to know the weight of an
 edge. Dijkstra's algorithm cannot handle negative weights.
 Furthermore, although it works correctly with zero-weight edges,
 some of the methods of this class make guarantees based on
 assuming positive weights that they cannot make if there are
 zero-weight edges.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>e</CODE> - Edge for which the algorithm needs to know a weight
<DT><B>Returns:</B><DD>Your application's weight for e</DL>
</DD>
</DL>
<HR>

<A NAME="shortestPathFound(jdsl.graph.api.Vertex, int)"><!-- --></A><H3>
shortestPathFound</H3>
<PRE>
protected void <B>shortestPathFound</B>(<A HREF="../../../jdsl/graph/api/Vertex.html" title="interface in jdsl.graph.api">Vertex</A>&nbsp;v,
                                 int&nbsp;vDist)</PRE>
<DL>
<DD>Can be overridden to give you a notification when the shortest
 path to a vertex is determined.  The algorithm calls this method
 at most once per vertex, after the vertex has been "finished"
 (i.e., when the path from s to the vertex is known).  The vertex
 will never again be touched or considered by the algorithm.
 <p>
 Note that there is no corresponding get-method; the algorithm
 does not need this information again, so the only constraints on
 what you do with the information are those imposed by your
 application.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - Vertex that the algorithm just finished<DD><CODE>vDist</CODE> - Distance of v from the source</DL>
</DD>
</DL>
<HR>

<A NAME="vertexNotReachable(jdsl.graph.api.Vertex)"><!-- --></A><H3>
vertexNotReachable</H3>
<PRE>
protected void <B>vertexNotReachable</B>(<A HREF="../../../jdsl/graph/api/Vertex.html" title="interface in jdsl.graph.api">Vertex</A>&nbsp;v)</PRE>
<DL>
<DD>Can be overridden in any application that involves unreachable
 vertices.  Called every time a vertex with distance INFINITY
 comes off the priority queue.  When it has been called once, it
 should subsequently be called for all remaining vertices, until
 the priority queue is empty.
 <p>
 Note that there is no corresponding get-method; the algorithm
 does not need this information again, so the only constraints on
 what you do with the information are those imposed by your
 application.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - Vertex which the algorithm just found to be unreachable
 from the source</DL>
</DD>
</DL>
<HR>

<A NAME="edgeRelaxed(jdsl.graph.api.Vertex, int, jdsl.graph.api.Edge, int, jdsl.graph.api.Vertex, int)"><!-- --></A><H3>
edgeRelaxed</H3>
<PRE>
protected void <B>edgeRelaxed</B>(<A HREF="../../../jdsl/graph/api/Vertex.html" title="interface in jdsl.graph.api">Vertex</A>&nbsp;u,
                           int&nbsp;uDist,
                           <A HREF="../../../jdsl/graph/api/Edge.html" title="interface in jdsl.graph.api">Edge</A>&nbsp;uv,
                           int&nbsp;uvWeight,
                           <A HREF="../../../jdsl/graph/api/Vertex.html" title="interface in jdsl.graph.api">Vertex</A>&nbsp;v,
                           int&nbsp;vDist)</PRE>
<DL>
<DD>Can be overridden in any application where the edges considered
 for the shortest-path tree matter.  Called every time an edge
 leading to a vertex is examined (relaxed); this can happen many
 times per vertex.  If udist + uvweight is less than vDist, there
 is a shorter path to v, via u and uv, than the shortest path to v
 previously known, so v is updated in the priority queue.  This
 method notifies you before such a calculation is made, whether
 the calculation results in an update or not.
 <p>
 For every vertex reachable from the source, except the source,
 this method will be called at least once before the vertex is
 finished.  Once a vertex has been finished, this method will
 never be called for that vertex again.
 <p>
 Note that there is no corresponding
 get-method; the algorithm does not need this information again,
 so the only constraints on what you do with the information are
 those imposed by your application.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>u</CODE> - Vertex about to be finished, from which an edge to v
 is being explored<DD><CODE>uDist</CODE> - The final distance to u (will soon be passed as
 svDist to shortestPathFound(.))<DD><CODE>uv</CODE> - Edge being explored<DD><CODE>uvWeight</CODE> - Weight of uv<DD><CODE>v</CODE> - Vertex being investigated: the best-known-path to it
 will be updated if the path via u and uv is better<DD><CODE>vDist</CODE> - The present, possibly suboptimal, distance of v
 from s</DL>
</DD>
</DL>
<HR>

<A NAME="shouldContinue()"><!-- --></A><H3>
shouldContinue</H3>
<PRE>
protected boolean <B>shouldContinue</B>()</PRE>
<DL>
<DD>Can be overridden in any application where the full shortest-path
 tree is not needed and the algorithm should terminate early.
 executeAll(.) checks the return from this method before each call
 to doOneIteration().  The default implementation just returns
 <code>true</code>, so executeAll(.) continues until the full
 shortest-path tree is built.  Notice that if you are calling
 doOneIteration() manually, this method is irrelevant; only
 executeAll(.) calls this method.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>Whether to continue running the algorithm</DL>
</DD>
</DL>
<HR>

<A NAME="isFinished(jdsl.graph.api.Vertex)"><!-- --></A><H3>
isFinished</H3>
<PRE>
protected boolean <B>isFinished</B>(<A HREF="../../../jdsl/graph/api/Vertex.html" title="interface in jdsl.graph.api">Vertex</A>&nbsp;v)</PRE>
<DL>
<DD>Tests whether a vertex has been reached.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - a vertex
<DT><B>Returns:</B><DD>Whether v has been marked as finished</DL>
</DD>
</DL>
<HR>

<A NAME="setLocator(jdsl.graph.api.Vertex, jdsl.core.api.Locator)"><!-- --></A><H3>
setLocator</H3>
<PRE>
protected void <B>setLocator</B>(<A HREF="../../../jdsl/graph/api/Vertex.html" title="interface in jdsl.graph.api">Vertex</A>&nbsp;v,
                          <A HREF="../../../jdsl/core/api/Locator.html" title="interface in jdsl.core.api">Locator</A>&nbsp;vLoc)</PRE>
<DL>
<DD>Can be overridden to supply a way of storing and retrieving one
 locator per vertex.  Will be called only once per vertex, during
 initialization.  The default implementation decorates each vertex
 with its locator.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - Vertex to decorate with a locator<DD><CODE>vLoc</CODE> - the locator with which to decorate v<DT><B>See Also:</B><DD><A HREF="../../../jdsl/graph/algo/IntegerDijkstraTemplate.html#getLocator(jdsl.graph.api.Vertex)"><CODE>getLocator(Vertex)</CODE></A>, 
<A HREF="../../../jdsl/core/api/Decorable.html#set(java.lang.Object, java.lang.Object)"><CODE>Decorable.set(Object,Object)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getLocator(jdsl.graph.api.Vertex)"><!-- --></A><H3>
getLocator</H3>
<PRE>
protected <A HREF="../../../jdsl/core/api/Locator.html" title="interface in jdsl.core.api">Locator</A> <B>getLocator</B>(<A HREF="../../../jdsl/graph/api/Vertex.html" title="interface in jdsl.graph.api">Vertex</A>&nbsp;v)</PRE>
<DL>
<DD>Can be overridden to supply a way of storing and retrieving one
 locator per vertex.  This is the counterpart to setLocator(.)
 but may be called many times.  The default implementation uses
 the decoration of each vertex.  The algorithm calls this method
 whenever it needs to update the best distance it knows for a
 vertex, which requires updating the priority queue.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - Vertex previously decorated with a locator
<DT><B>Returns:</B><DD>Locator associated with v in the earlier setLocator(.) call<DT><B>See Also:</B><DD><A HREF="../../../jdsl/graph/algo/IntegerDijkstraTemplate.html#setLocator(jdsl.graph.api.Vertex, jdsl.core.api.Locator)"><CODE>setLocator(Vertex,Locator)</CODE></A>, 
<A HREF="../../../jdsl/core/api/Decorable.html#get(java.lang.Object)"><CODE>Decorable.get(Object)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setEdgeToParent(jdsl.graph.api.Vertex, jdsl.graph.api.Edge)"><!-- --></A><H3>
setEdgeToParent</H3>
<PRE>
protected void <B>setEdgeToParent</B>(<A HREF="../../../jdsl/graph/api/Vertex.html" title="interface in jdsl.graph.api">Vertex</A>&nbsp;v,
                               <A HREF="../../../jdsl/graph/api/Edge.html" title="interface in jdsl.graph.api">Edge</A>&nbsp;vEdge)</PRE>
<DL>
<DD>Can be overridden to supply a way of storing and retrieving one
 edge per vertex.  The default implementation decorates each vertex
 with its edge.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - Vertex to decorate with an edge<DD><CODE>vEdge</CODE> - the with which to decorate v<DT><B>See Also:</B><DD><A HREF="../../../jdsl/graph/algo/IntegerDijkstraTemplate.html#getEdgeToParent(jdsl.graph.api.Vertex)"><CODE>getEdgeToParent(Vertex)</CODE></A>, 
<A HREF="../../../jdsl/core/api/Decorable.html#set(java.lang.Object, java.lang.Object)"><CODE>Decorable.set(Object,Object)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="newPQ()"><!-- --></A><H3>
newPQ</H3>
<PRE>
protected <A HREF="../../../jdsl/core/api/PriorityQueue.html" title="interface in jdsl.core.api">PriorityQueue</A> <B>newPQ</B>()</PRE>
<DL>
<DD>Can be overridden to supply a priority queue of your
 choosing, but the default implementation, which gives an empty   
 jdsl.core.ref.ArrayHeap, is probably sufficient for most
 purposes.  The priority queue must be able to accept keys of
 type Integer.  If you choose to override the method, 
 for typical applications you should return an empty priority
 queue.  If necessary, it can be preinitialized, although you
 will need to accommodate that fact in other methods.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>PriorityQueue to be used by the algorithm</DL>
</DD>
</DL>
<HR>

<A NAME="initMap()"><!-- --></A><H3>
initMap</H3>
<PRE>
protected void <B>initMap</B>()</PRE>
<DL>
<DD>Can be overridden to initialize a locator-lookup data structure
 of your choosing, but the default implementation, which decorates
 each vertex with its locator, is probably sufficient for most
 purposes.  This method is called by the algorithm before any call
 to setLocator(.).  The best reason to override this method is
 that you have some other way to implement set/getLocator(.).  In
 that case, override this method to do any necessary
 initialization of your data structure.<p>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="incidentEdges(jdsl.graph.api.Vertex)"><!-- --></A><H3>
incidentEdges</H3>
<PRE>
protected <A HREF="../../../jdsl/graph/api/EdgeIterator.html" title="interface in jdsl.graph.api">EdgeIterator</A> <B>incidentEdges</B>(<A HREF="../../../jdsl/graph/api/Vertex.html" title="interface in jdsl.graph.api">Vertex</A>&nbsp;v)</PRE>
<DL>
<DD>Can be overridden in any application where the default choice of
 edges to consider at any vertex is not satisfactory.  The default
 is to consider all outgoing and all undirected edges from a given
 vertex.  Example:  if you have a directed graph but want to view it
 as undirected for purposes of building a shortest-path tree, you
 should override this method to read<br>
 <code> return G.incidentEdges(v, EdgeDirection.IN | EdgeDirection.OUT);
 </code>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - Vertex soon to be finished by the algorithm
<DT><B>Returns:</B><DD>All the interesting edges of v -- i.e., all edges whose
 weights you want the algorithm to inspect in considering
 alternative routes to vertices adjacent to v</DL>
</DD>
</DL>
<HR>

<A NAME="destination(jdsl.graph.api.Vertex, jdsl.graph.api.Edge)"><!-- --></A><H3>
destination</H3>
<PRE>
protected <A HREF="../../../jdsl/graph/api/Vertex.html" title="interface in jdsl.graph.api">Vertex</A> <B>destination</B>(<A HREF="../../../jdsl/graph/api/Vertex.html" title="interface in jdsl.graph.api">Vertex</A>&nbsp;origin,
                             <A HREF="../../../jdsl/graph/api/Edge.html" title="interface in jdsl.graph.api">Edge</A>&nbsp;e)</PRE>
<DL>
<DD>Can be overridden to supply the destination of an edge, although I
 can't think of any reason to do so.  Presently implemented with
 opposite(.), so it works even if the edge is incoming to v (see the
 example under incidentEdges(.)).  Called by the core algorithm when
 it is about to finish <code>origin</code> and needs all its
 adjacent vertices.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>origin</CODE> - Vertex soon to be finished by the algorithm<DD><CODE>e</CODE> - Edge incident on <code>origin</code> according to
 incidentEdges(.)
<DT><B>Returns:</B><DD>the vertex opposite <code>origin</code> along
 <code>e</code></DL>
</DD>
</DL>
<HR>

<A NAME="vertices()"><!-- --></A><H3>
vertices</H3>
<PRE>
protected <A HREF="../../../jdsl/graph/api/VertexIterator.html" title="interface in jdsl.graph.api">VertexIterator</A> <B>vertices</B>()</PRE>
<DL>
<DD>Can be overridden to consider a subset of the vertices in the
 graph, although I can't think of any reason to do so.  Note that
 overriding this method will probably also require overriding
 incidentEdges(.), in order to avoid edges leading to vertices not
 in the subset.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>Iterator over all vertices to be initially put in the
 priority queue and eventually finished by the algorithm</DL>
</DD>
</DL>
<HR>

<A NAME="isReachable(jdsl.graph.api.Vertex)"><!-- --></A><H3>
isReachable</H3>
<PRE>
public final boolean <B>isReachable</B>(<A HREF="../../../jdsl/graph/api/Vertex.html" title="interface in jdsl.graph.api">Vertex</A>&nbsp;v)</PRE>
<DL>
<DD>Tests whether a vertex is reachable from the source.  The method
 can be invoked at any time during the single-step execution of
 the algorithm.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - a vertex
<DT><B>Returns:</B><DD>whether v is reachable from the source</DL>
</DD>
</DL>
<HR>

<A NAME="distance(jdsl.graph.api.Vertex)"><!-- --></A><H3>
distance</H3>
<PRE>
public final int <B>distance</B>(<A HREF="../../../jdsl/graph/api/Vertex.html" title="interface in jdsl.graph.api">Vertex</A>&nbsp;v)
                   throws <A HREF="../../../jdsl/graph/algo/InvalidQueryException.html" title="class in jdsl.graph.algo">InvalidQueryException</A></PRE>
<DL>
<DD>Returns the distance of a vertex from the source.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - a vertex
<DT><B>Returns:</B><DD>the distance of v from the source
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../jdsl/graph/algo/InvalidQueryException.html" title="class in jdsl.graph.algo">InvalidQueryException</A></CODE> - if v has not been reached yet</DL>
</DD>
</DL>
<HR>

<A NAME="getEdgeToParent(jdsl.graph.api.Vertex)"><!-- --></A><H3>
getEdgeToParent</H3>
<PRE>
public <A HREF="../../../jdsl/graph/api/Edge.html" title="interface in jdsl.graph.api">Edge</A> <B>getEdgeToParent</B>(<A HREF="../../../jdsl/graph/api/Vertex.html" title="interface in jdsl.graph.api">Vertex</A>&nbsp;v)
                     throws <A HREF="../../../jdsl/graph/algo/InvalidQueryException.html" title="class in jdsl.graph.algo">InvalidQueryException</A></PRE>
<DL>
<DD>Can be overridden to supply a way of storing and retrieving one
 edge per vertex.  This is the counterpart to setEdgeToParent(.)
 but may be called many times.  The default implementation uses
 the decoration of each vertex.  The algorithm calls this method
 whenever it needs to update the best distance it knows for a
 vertex, which requires updating the edge to parent.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - Vertex previously labeled with an edge
<DT><B>Returns:</B><DD>Edge associated with v in the earlier setEdgeToParent(.)
 call
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../jdsl/graph/algo/InvalidQueryException.html" title="class in jdsl.graph.algo">InvalidQueryException</A></CODE> - if v is the source or has not
 been reached yet<DT><B>See Also:</B><DD><A HREF="../../../jdsl/graph/algo/IntegerDijkstraTemplate.html#setEdgeToParent(jdsl.graph.api.Vertex, jdsl.graph.api.Edge)"><CODE>setEdgeToParent(Vertex,Edge)</CODE></A>, 
<A HREF="../../../jdsl/core/api/Decorable.html#get(java.lang.Object)"><CODE>Decorable.get(Object)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="init(jdsl.graph.api.InspectableGraph, jdsl.graph.api.Vertex)"><!-- --></A><H3>
init</H3>
<PRE>
public void <B>init</B>(<A HREF="../../../jdsl/graph/api/InspectableGraph.html" title="interface in jdsl.graph.api">InspectableGraph</A>&nbsp;g,
                 <A HREF="../../../jdsl/graph/api/Vertex.html" title="interface in jdsl.graph.api">Vertex</A>&nbsp;source)</PRE>
<DL>
<DD>Called automatically by executeAll(); must be called by the client
 prior to the first call to doOneIteration() if finer-grained
 control of the algorithm is needed.  The method initializes
 instance variables and then puts all vertices in the PQ with
 initial distances, and records their respective locators.  Can be
 overridden, although I can't think of any reason to do so.
 <p>
 Calls the following methods that can be overridden:  newPQ(),
 initMap(), vertices(), setLocator(.).
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>g</CODE> - Graph on which to execute the algorithm<DD><CODE>source</CODE> - Vertex at which to root the shortest-path tree</DL>
</DD>
</DL>
<HR>

<A NAME="cleanup()"><!-- --></A><H3>
cleanup</H3>
<PRE>
public void <B>cleanup</B>()</PRE>
<DL>
<DD>Removes the decorations from the vertices.  Its invocation is the
 user's responsibility.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="doOneIteration()"><!-- --></A><H3>
doOneIteration</H3>
<PRE>
public final void <B>doOneIteration</B>()
                          throws <A HREF="../../../jdsl/graph/api/InvalidEdgeException.html" title="class in jdsl.graph.api">InvalidEdgeException</A></PRE>
<DL>
<DD>Can be called manually to single-step the algorithm, but you must
 call init(.) before the first call to this method.  Finishes one
 vertex and updates all adjacent vertices.  If the vertex that
 gets finished was reachable from the source, this method expands
 the shortest-path tree by one vertex.
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../jdsl/graph/api/InvalidEdgeException.html" title="class in jdsl.graph.api">InvalidEdgeException</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="runUntil()"><!-- --></A><H3>
runUntil</H3>
<PRE>
protected final void <B>runUntil</B>()</PRE>
<DL>
<DD>Repeatedly calls method doOneIteration() until either the
 priority queue is empty or method shouldContinue() returns false.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="execute(jdsl.graph.api.InspectableGraph, jdsl.graph.api.Vertex)"><!-- --></A><H3>
execute</H3>
<PRE>
public final void <B>execute</B>(<A HREF="../../../jdsl/graph/api/InspectableGraph.html" title="interface in jdsl.graph.api">InspectableGraph</A>&nbsp;g,
                          <A HREF="../../../jdsl/graph/api/Vertex.html" title="interface in jdsl.graph.api">Vertex</A>&nbsp;source)</PRE>
<DL>
<DD>The easiest way to use the algorithm is to use this method.
 Calls init(.) once, then doOneIteration() repeatedly until
 either the PQ is empty or shouldContinue() returns false.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>g</CODE> - Graph on which to execute the algorithm<DD><CODE>source</CODE> - Vertex at which to root the shortest-path tree</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../jdsl/graph/algo/IntegerDijkstraPathfinder.html" title="class in jdsl.graph.algo"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../jdsl/graph/algo/IntegerPrimTemplate.html" title="class in jdsl.graph.algo"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="IntegerDijkstraTemplate.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
