<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.4.2) on Thu Sep 01 06:58:35 EDT 2005 -->
<TITLE>
IntegerPrimTemplate (Docs for JDSL 2.1.1)
</TITLE>

<META NAME="keywords" CONTENT="jdsl.graph.algo.IntegerPrimTemplate class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="IntegerPrimTemplate (Docs for JDSL 2.1.1)";
}
</SCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../jdsl/graph/algo/IntegerDijkstraTemplate.html" title="class in jdsl.graph.algo"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../jdsl/graph/algo/TopologicalSort.html" title="class in jdsl.graph.algo"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="IntegerPrimTemplate.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
jdsl.graph.algo</FONT>
<BR>
Class IntegerPrimTemplate</H2>
<PRE>
<A HREF="http://java.sun.com/j2se/1.4/docs/api/java/lang/Object.html" title="class or interface in java.lang">java.lang.Object</A>
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by"><B>jdsl.graph.algo.IntegerPrimTemplate</B>
</PRE>
<HR>
<DL>
<DT>public abstract class <B>IntegerPrimTemplate</B><DT>extends <A HREF="http://java.sun.com/j2se/1.4/docs/api/java/lang/Object.html" title="class or interface in java.lang">Object</A></DL>

<P>
Implementation of the algorithm of Prim and Jarnik for finding a
 minimum spanning tree, using the template-method
 pattern:  the core functionality is coded in a few final methods
 that call overridable methods to do some of the work.  The methods
 of this class are in four categories:
 <ul>
 
 <li>a method you must override to make the compiler happy:  
 You must override weight(Edge) to supply the algorithm with a
 weight for every edge in the graph.  Note that the Prim-Jarnik
 algorithm cannot handle negative-weight edges.
 
 <li>"output" methods that you must, realistically speaking, override
 in order to get useful information out of the algorithm and into
 your application domain:  You will need
 to override at least one of treeEdgeFound(.), relaxingEdge(.),
 and vertexNotReachable(.).  For every vertex in the graph (or
 every vertex you allow the algorithm to consider), either
 treeEdgeFound(.) or vertexNotReachable(.) will be called, and
 will be called exactly once.  When that has occurred, the vertex is
 considered to be "finished"; it will not be considered again by the
 algorithm.  Finally, relaxingEdge(.) will be
 called every time an edge to an unfinished vertex is explored.
 
 <li>overridable methods that will need to be overridden only
 for special applications:  See the comments for shouldContinue(),
 setLocator(.), getLocator(.), newPQ(), initMap(), incidentEdges(.),
 destination(.), allVertices(), and init(.) (which has a split role
 between this category of methods and the next).
 
 <li>methods composing the core of the algorithm, which cannot be
 overridden (or, in the case of init(.), should rarely be overridden):
 You can run the
 algorithm in either of two ways.  If you want to run the whole
 algorithm at once, use either version of executeAll(.).  It will call
 doOneIteration() multiple times, and doOneIteration() will call
 your overridden output methods as it encounters vertices.  Instead
 of using executeAll(.), you can single-step the algorithm by
 calling init(.) to initialize, then calling doOneIteration() repeatedly.
 </ul>
 
 Note that it is possible to confuse the algorithm by doing things
 like modifying the graph, messing with the priority queue, or changing
 edge weights while it is running.
<P>

<P>
<DL>
<DT><B>Author:</B></DT>
  <DD>Mark Handy, Galina Shubina</DD>
</DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Field Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../jdsl/graph/api/InspectableGraph.html" title="interface in jdsl.graph.api">InspectableGraph</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../jdsl/graph/algo/IntegerPrimTemplate.html#G">G</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="http://java.sun.com/j2se/1.4/docs/api/java/lang/Integer.html" title="class or interface in java.lang">Integer</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../jdsl/graph/algo/IntegerPrimTemplate.html#INFINITY">INFINITY</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="http://java.sun.com/j2se/1.4/docs/api/java/util/Hashtable.html" title="class or interface in java.util">Hashtable</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../jdsl/graph/algo/IntegerPrimTemplate.html#locators">locators</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../jdsl/core/api/PriorityQueue.html" title="interface in jdsl.core.api">PriorityQueue</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../jdsl/graph/algo/IntegerPrimTemplate.html#Q">Q</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../jdsl/graph/api/Vertex.html" title="interface in jdsl.graph.api">Vertex</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../jdsl/graph/algo/IntegerPrimTemplate.html#source">source</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../jdsl/graph/algo/IntegerPrimTemplate.html#treeWeight">treeWeight</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="http://java.sun.com/j2se/1.4/docs/api/java/lang/Integer.html" title="class or interface in java.lang">Integer</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../jdsl/graph/algo/IntegerPrimTemplate.html#ZERO">ZERO</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../jdsl/graph/algo/IntegerPrimTemplate.html#IntegerPrimTemplate()">IntegerPrimTemplate</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../jdsl/graph/api/VertexIterator.html" title="interface in jdsl.graph.api">VertexIterator</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../jdsl/graph/algo/IntegerPrimTemplate.html#allVertices()">allVertices</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Can be overridden to consider a subset of the vertices in the
 graph, although I can't think of any reason to do so.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../jdsl/graph/algo/IntegerPrimTemplate.html#badWeight(jdsl.graph.api.Vertex, jdsl.graph.api.Edge, int)">badWeight</A></B>(<A HREF="../../../jdsl/graph/api/Vertex.html" title="interface in jdsl.graph.api">Vertex</A>&nbsp;u,
          <A HREF="../../../jdsl/graph/api/Edge.html" title="interface in jdsl.graph.api">Edge</A>&nbsp;uv,
          int&nbsp;uvweight)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Can be overridden to handle edges that have zero or
 negative weights.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../jdsl/graph/api/Vertex.html" title="interface in jdsl.graph.api">Vertex</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../jdsl/graph/algo/IntegerPrimTemplate.html#destination(jdsl.graph.api.Vertex, jdsl.graph.api.Edge)">destination</A></B>(<A HREF="../../../jdsl/graph/api/Vertex.html" title="interface in jdsl.graph.api">Vertex</A>&nbsp;origin,
            <A HREF="../../../jdsl/graph/api/Edge.html" title="interface in jdsl.graph.api">Edge</A>&nbsp;e)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Can be overridden to supply the destination of an edge, although I
 can't think of any reason to do so.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../jdsl/graph/algo/IntegerPrimTemplate.html#doOneIteration()">doOneIteration</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Can be called manually to single-step the
 algorithm, but you must call init(.) before the first call to this
 method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../jdsl/graph/algo/IntegerPrimTemplate.html#executeAll(jdsl.graph.api.InspectableGraph, jdsl.graph.api.Vertex)">executeAll</A></B>(<A HREF="../../../jdsl/graph/api/InspectableGraph.html" title="interface in jdsl.graph.api">InspectableGraph</A>&nbsp;g,
           <A HREF="../../../jdsl/graph/api/Vertex.html" title="interface in jdsl.graph.api">Vertex</A>&nbsp;src)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Just like the other version of executeAll(.), but with 
 infinity=Integer.MAX_VALUE</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../jdsl/graph/algo/IntegerPrimTemplate.html#executeAll(jdsl.graph.api.InspectableGraph, jdsl.graph.api.Vertex, int)">executeAll</A></B>(<A HREF="../../../jdsl/graph/api/InspectableGraph.html" title="interface in jdsl.graph.api">InspectableGraph</A>&nbsp;g,
           <A HREF="../../../jdsl/graph/api/Vertex.html" title="interface in jdsl.graph.api">Vertex</A>&nbsp;src,
           int&nbsp;infinity)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The easiest way to use the algorithm is to use this method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../jdsl/core/api/Locator.html" title="interface in jdsl.core.api">Locator</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../jdsl/graph/algo/IntegerPrimTemplate.html#getLocator(jdsl.graph.api.Vertex)">getLocator</A></B>(<A HREF="../../../jdsl/graph/api/Vertex.html" title="interface in jdsl.graph.api">Vertex</A>&nbsp;u)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Can be overridden to supply a way of storing and retrieving one
 locator per vertex.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../jdsl/graph/api/EdgeIterator.html" title="interface in jdsl.graph.api">EdgeIterator</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../jdsl/graph/algo/IntegerPrimTemplate.html#incidentEdges(jdsl.graph.api.Vertex)">incidentEdges</A></B>(<A HREF="../../../jdsl/graph/api/Vertex.html" title="interface in jdsl.graph.api">Vertex</A>&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Can be overridden in any application where the default choice of
 edges to consider at any vertex is not satisfactory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../jdsl/graph/algo/IntegerPrimTemplate.html#init(jdsl.graph.api.InspectableGraph, jdsl.graph.api.Vertex, int)">init</A></B>(<A HREF="../../../jdsl/graph/api/InspectableGraph.html" title="interface in jdsl.graph.api">InspectableGraph</A>&nbsp;g,
     <A HREF="../../../jdsl/graph/api/Vertex.html" title="interface in jdsl.graph.api">Vertex</A>&nbsp;src,
     int&nbsp;infinity)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Called automatically by executeAll(); must be called by the client
 prior to the first call to doOneIteration() if finer-grained
 control of the algorithm is needed.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../jdsl/graph/algo/IntegerPrimTemplate.html#initMap()">initMap</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Can be overridden to initialize a locator-lookup data structure
 of your choosing, but the default implementation, which uses a
 java.util.Hashtable, is probably sufficient for most purposes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../jdsl/core/api/PriorityQueue.html" title="interface in jdsl.core.api">PriorityQueue</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../jdsl/graph/algo/IntegerPrimTemplate.html#newPQ()">newPQ</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Can be overridden to supply a priority queue of your
 choosing, but the default implementation, which gives an empty   
 jdsl.core.ref.ArrayHeap, is probably sufficient for most
 purposes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../jdsl/graph/algo/IntegerPrimTemplate.html#relaxingEdge(jdsl.graph.api.Vertex, jdsl.graph.api.Edge, int, jdsl.graph.api.Vertex, int)">relaxingEdge</A></B>(<A HREF="../../../jdsl/graph/api/Vertex.html" title="interface in jdsl.graph.api">Vertex</A>&nbsp;u,
             <A HREF="../../../jdsl/graph/api/Edge.html" title="interface in jdsl.graph.api">Edge</A>&nbsp;uv,
             int&nbsp;uvweight,
             <A HREF="../../../jdsl/graph/api/Vertex.html" title="interface in jdsl.graph.api">Vertex</A>&nbsp;v,
             int&nbsp;vdist)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Can be overridden in any application where the edges considered
 for the minimum spanning tree matter.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../jdsl/graph/algo/IntegerPrimTemplate.html#setLocator(jdsl.graph.api.Vertex, jdsl.core.api.Locator)">setLocator</A></B>(<A HREF="../../../jdsl/graph/api/Vertex.html" title="interface in jdsl.graph.api">Vertex</A>&nbsp;u,
           <A HREF="../../../jdsl/core/api/Locator.html" title="interface in jdsl.core.api">Locator</A>&nbsp;ulocInPQ)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Can be overridden to supply a way of storing and retrieving
 one locator per vertex.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../jdsl/graph/algo/IntegerPrimTemplate.html#shouldContinue()">shouldContinue</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Can be overridden in any application where the full
 minimum spanning tree is not needed and the algorithm should
 terminate early.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../jdsl/graph/algo/IntegerPrimTemplate.html#treeEdgeFound(jdsl.graph.api.Vertex, jdsl.graph.api.Edge, int)">treeEdgeFound</A></B>(<A HREF="../../../jdsl/graph/api/Vertex.html" title="interface in jdsl.graph.api">Vertex</A>&nbsp;v,
              <A HREF="../../../jdsl/graph/api/Edge.html" title="interface in jdsl.graph.api">Edge</A>&nbsp;vparent,
              int&nbsp;treeWeight)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Can be overridden to give you a notification when a vertex is
 added to the minimum spanning tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../jdsl/graph/algo/IntegerPrimTemplate.html#vertexNotReachable(jdsl.graph.api.Vertex)">vertexNotReachable</A></B>(<A HREF="../../../jdsl/graph/api/Vertex.html" title="interface in jdsl.graph.api">Vertex</A>&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Can be overridden in any application that involves unreachable
 vertices.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected abstract &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../jdsl/graph/algo/IntegerPrimTemplate.html#weight(jdsl.graph.api.Edge)">weight</A></B>(<A HREF="../../../jdsl/graph/api/Edge.html" title="interface in jdsl.graph.api">Edge</A>&nbsp;e)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Must be overridden to supply a way of getting a positive weight
 for every edge in the graph.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.lang.<A HREF="http://java.sun.com/j2se/1.4/docs/api/java/lang/Object.html" title="class or interface in java.lang">Object</A></B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="http://java.sun.com/j2se/1.4/docs/api/java/lang/Object.html#clone()" title="class or interface in java.lang">clone</A>, <A HREF="http://java.sun.com/j2se/1.4/docs/api/java/lang/Object.html#equals(java.lang.Object)" title="class or interface in java.lang">equals</A>, <A HREF="http://java.sun.com/j2se/1.4/docs/api/java/lang/Object.html#finalize()" title="class or interface in java.lang">finalize</A>, <A HREF="http://java.sun.com/j2se/1.4/docs/api/java/lang/Object.html#getClass()" title="class or interface in java.lang">getClass</A>, <A HREF="http://java.sun.com/j2se/1.4/docs/api/java/lang/Object.html#hashCode()" title="class or interface in java.lang">hashCode</A>, <A HREF="http://java.sun.com/j2se/1.4/docs/api/java/lang/Object.html#notify()" title="class or interface in java.lang">notify</A>, <A HREF="http://java.sun.com/j2se/1.4/docs/api/java/lang/Object.html#notifyAll()" title="class or interface in java.lang">notifyAll</A>, <A HREF="http://java.sun.com/j2se/1.4/docs/api/java/lang/Object.html#toString()" title="class or interface in java.lang">toString</A>, <A HREF="http://java.sun.com/j2se/1.4/docs/api/java/lang/Object.html#wait()" title="class or interface in java.lang">wait</A>, <A HREF="http://java.sun.com/j2se/1.4/docs/api/java/lang/Object.html#wait(long)" title="class or interface in java.lang">wait</A>, <A HREF="http://java.sun.com/j2se/1.4/docs/api/java/lang/Object.html#wait(long, int)" title="class or interface in java.lang">wait</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Field Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="Q"><!-- --></A><H3>
Q</H3>
<PRE>
protected <A HREF="../../../jdsl/core/api/PriorityQueue.html" title="interface in jdsl.core.api">PriorityQueue</A> <B>Q</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="G"><!-- --></A><H3>
G</H3>
<PRE>
protected <A HREF="../../../jdsl/graph/api/InspectableGraph.html" title="interface in jdsl.graph.api">InspectableGraph</A> <B>G</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="source"><!-- --></A><H3>
source</H3>
<PRE>
protected <A HREF="../../../jdsl/graph/api/Vertex.html" title="interface in jdsl.graph.api">Vertex</A> <B>source</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="ZERO"><!-- --></A><H3>
ZERO</H3>
<PRE>
protected <A HREF="http://java.sun.com/j2se/1.4/docs/api/java/lang/Integer.html" title="class or interface in java.lang">Integer</A> <B>ZERO</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="INFINITY"><!-- --></A><H3>
INFINITY</H3>
<PRE>
protected <A HREF="http://java.sun.com/j2se/1.4/docs/api/java/lang/Integer.html" title="class or interface in java.lang">Integer</A> <B>INFINITY</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="locators"><!-- --></A><H3>
locators</H3>
<PRE>
protected <A HREF="http://java.sun.com/j2se/1.4/docs/api/java/util/Hashtable.html" title="class or interface in java.util">Hashtable</A> <B>locators</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="treeWeight"><!-- --></A><H3>
treeWeight</H3>
<PRE>
protected int <B>treeWeight</B></PRE>
<DL>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="IntegerPrimTemplate()"><!-- --></A><H3>
IntegerPrimTemplate</H3>
<PRE>
public <B>IntegerPrimTemplate</B>()</PRE>
<DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="weight(jdsl.graph.api.Edge)"><!-- --></A><H3>
weight</H3>
<PRE>
protected abstract int <B>weight</B>(<A HREF="../../../jdsl/graph/api/Edge.html" title="interface in jdsl.graph.api">Edge</A>&nbsp;e)</PRE>
<DL>
<DD>Must be overridden to supply a way of getting a positive weight
 for every edge in the graph.  This method gets called by the
 algorithm when the algorithm needs to know the weight of an
 edge. Prim's algorithm cannot handle negative
 weights.  Furthermore, although it works correctly with
 zero-weight edges, some of the methods of this class make
 guarantees based on assuming positive weights that they cannot
 make if there are zero-weight edges.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>e</CODE> - Edge for which the algorithm needs to know a weight
<DT><B>Returns:</B><DD>Your application's weight for e</DL>
</DD>
</DL>
<HR>

<A NAME="treeEdgeFound(jdsl.graph.api.Vertex, jdsl.graph.api.Edge, int)"><!-- --></A><H3>
treeEdgeFound</H3>
<PRE>
protected void <B>treeEdgeFound</B>(<A HREF="../../../jdsl/graph/api/Vertex.html" title="interface in jdsl.graph.api">Vertex</A>&nbsp;v,
                             <A HREF="../../../jdsl/graph/api/Edge.html" title="interface in jdsl.graph.api">Edge</A>&nbsp;vparent,
                             int&nbsp;treeWeight)</PRE>
<DL>
<DD>Can be overridden to give you a notification when a vertex is
 added to the minimum spanning tree.  The algorithm calls this
 method at most once per vertex, after the vertex has been
 "finished" (i.e., when the path from s to the vertex is known).  The
 vertex will never again be touched or considered by the
 algorithm.
 <p>
 Note that there is no corresponding get-method; the
 algorithm does not need this information again, so the
 only constraints on what you do with the information are those
 imposed by your application.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - Vertex that the algorithm just finished<DD><CODE>vparent</CODE> - Edge leading into v in the minimum spanning tree<DD><CODE>treeWeight</CODE> - the total weight of all edges known to be
 in the tree at this point in the execution of the algorithm, including
 vparent</DL>
</DD>
</DL>
<HR>

<A NAME="vertexNotReachable(jdsl.graph.api.Vertex)"><!-- --></A><H3>
vertexNotReachable</H3>
<PRE>
protected void <B>vertexNotReachable</B>(<A HREF="../../../jdsl/graph/api/Vertex.html" title="interface in jdsl.graph.api">Vertex</A>&nbsp;v)</PRE>
<DL>
<DD>Can be overridden in any application that involves unreachable
 vertices.  Called every time a vertex with distance INFINITY comes
 off the priority queue.  When it has been called once, it should
 subsequently be called for all remaining vertices, until the 
 priority queue is empty.
 <p>
 Note that there is no corresponding get-method; the
 algorithm does not need this information again, so the
 only constraints on what you do with the information are those
 imposed by your application.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - Vertex which the algorithm just found to be
 unreachable from the source</DL>
</DD>
</DL>
<HR>

<A NAME="relaxingEdge(jdsl.graph.api.Vertex, jdsl.graph.api.Edge, int, jdsl.graph.api.Vertex, int)"><!-- --></A><H3>
relaxingEdge</H3>
<PRE>
protected void <B>relaxingEdge</B>(<A HREF="../../../jdsl/graph/api/Vertex.html" title="interface in jdsl.graph.api">Vertex</A>&nbsp;u,
                            <A HREF="../../../jdsl/graph/api/Edge.html" title="interface in jdsl.graph.api">Edge</A>&nbsp;uv,
                            int&nbsp;uvweight,
                            <A HREF="../../../jdsl/graph/api/Vertex.html" title="interface in jdsl.graph.api">Vertex</A>&nbsp;v,
                            int&nbsp;vdist)</PRE>
<DL>
<DD>Can be overridden in any application where the edges considered
 for the minimum spanning tree matter.  Called every time an edge
 leading to a vertex is examined (relaxed); this can happen many
 times per vertex.  If uvweight is less than vdist, then uv is a
 better tree edge to v than the best edge to
 v previously known, so v is updated in the priority queue.
 This method notifies you before such a calculation is made,
 whether the calculation results in an update or not.
 <p>
 For every vertex reachable from the source, except the source,
 this method will be called at least once before the vertex is
 finished.  Once a vertex has been finished, this method will
 never be called for that vertex again.
 <p>
 Note that there is no corresponding
 get-method; the algorithm does not need this information again,
 so the only constraints on what you do with the information are
 those imposed by your application.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>u</CODE> - Vertex about to be finished, from which an edge to v
 is being explored<DD><CODE>uv</CODE> - Edge being explored<DD><CODE>uvweight</CODE> - Weight of uv<DD><CODE>v</CODE> - Vertex being investigated: the best-known-edge to it
 will be updated if the uv is a better edge<DD><CODE>vdist</CODE> - The present, possibly suboptimal, distance of v
 from the partially built spanning tree</DL>
</DD>
</DL>
<HR>

<A NAME="shouldContinue()"><!-- --></A><H3>
shouldContinue</H3>
<PRE>
protected boolean <B>shouldContinue</B>()</PRE>
<DL>
<DD>Can be overridden in any application where the full
 minimum spanning tree is not needed and the algorithm should
 terminate early.  executeAll(.) checks the return from this
 method before each call to doOneIteration().  The default
 implementation just returns <code>true</code>, so 
 executeAll(.) continues until the full tree is
 built.  Notice that if you are calling doOneIteration()
 manually, this method is irrelevant; only executeAll(.) calls
 this method.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>Whether to continue running the algorithm</DL>
</DD>
</DL>
<HR>

<A NAME="setLocator(jdsl.graph.api.Vertex, jdsl.core.api.Locator)"><!-- --></A><H3>
setLocator</H3>
<PRE>
protected void <B>setLocator</B>(<A HREF="../../../jdsl/graph/api/Vertex.html" title="interface in jdsl.graph.api">Vertex</A>&nbsp;u,
                          <A HREF="../../../jdsl/core/api/Locator.html" title="interface in jdsl.core.api">Locator</A>&nbsp;ulocInPQ)</PRE>
<DL>
<DD>Can be overridden to supply a way of storing and retrieving
 one locator per vertex.  Will be called exactly once per vertex,
 during initialization.  The default implementation uses the
 java.util.Hashtable initialized by initMap() to store one locator per vertex.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>u</CODE> - Vertex to label with a locator<DD><CODE>ulocInPQ</CODE> - the label<DT><B>See Also:</B><DD><A HREF="../../../jdsl/graph/algo/IntegerPrimTemplate.html#getLocator(jdsl.graph.api.Vertex)"><CODE>getLocator(Vertex)</CODE></A>, 
<A HREF="../../../jdsl/graph/algo/IntegerPrimTemplate.html#initMap()"><CODE>initMap()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getLocator(jdsl.graph.api.Vertex)"><!-- --></A><H3>
getLocator</H3>
<PRE>
protected <A HREF="../../../jdsl/core/api/Locator.html" title="interface in jdsl.core.api">Locator</A> <B>getLocator</B>(<A HREF="../../../jdsl/graph/api/Vertex.html" title="interface in jdsl.graph.api">Vertex</A>&nbsp;u)</PRE>
<DL>
<DD>Can be overridden to supply a way of storing and retrieving one
 locator per vertex.  This is the counterpart to setLocator(.)
 but may be called many times.  The default implementation
 queries the java.util.Hashtable mentioned in setLocator(.). The
 algorithm calls this method whenever it needs to update the
 best distance it knows for a vertex, which requires updating
 the priority queue.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>u</CODE> - Vertex previously labeled with a locator
<DT><B>Returns:</B><DD>Locator associated with u in the earlier setLocator(.) call<DT><B>See Also:</B><DD><A HREF="../../../jdsl/graph/algo/IntegerPrimTemplate.html#setLocator(jdsl.graph.api.Vertex, jdsl.core.api.Locator)"><CODE>setLocator(Vertex,Locator)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="newPQ()"><!-- --></A><H3>
newPQ</H3>
<PRE>
protected <A HREF="../../../jdsl/core/api/PriorityQueue.html" title="interface in jdsl.core.api">PriorityQueue</A> <B>newPQ</B>()</PRE>
<DL>
<DD>Can be overridden to supply a priority queue of your
 choosing, but the default implementation, which gives an empty   
 jdsl.core.ref.ArrayHeap, is probably sufficient for most
 purposes.  The priority queue must be able to accept keys of
 type Integer.  If you choose to override the method, 
 for typical applications you should return an empty priority
 queue.  If necessary, it can be preinitialized, although you
 will need to accommodate that fact in other methods.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>PriorityQueue to be used by the algorithm</DL>
</DD>
</DL>
<HR>

<A NAME="initMap()"><!-- --></A><H3>
initMap</H3>
<PRE>
protected void <B>initMap</B>()</PRE>
<DL>
<DD>Can be overridden to initialize a locator-lookup data structure
 of your choosing, but the default implementation, which uses a
 java.util.Hashtable, is probably sufficient for most purposes.
 This method is called by the algorithm before any call to
 setLocator(.).  The best reason to override this method is that
 you have some way other than a java.util.Hashtable to implement
 set/getLocator(.).  In that case, override this method to
 do any necessary initialization of your data structure.
 <p>
 Note that the algorithm never removes anything from
 <code>locators</code>, so if you want to execute the algorithm
 repeatedly, it is probably unwise to return the same data structure
 repeatedly from this method.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="incidentEdges(jdsl.graph.api.Vertex)"><!-- --></A><H3>
incidentEdges</H3>
<PRE>
protected <A HREF="../../../jdsl/graph/api/EdgeIterator.html" title="interface in jdsl.graph.api">EdgeIterator</A> <B>incidentEdges</B>(<A HREF="../../../jdsl/graph/api/Vertex.html" title="interface in jdsl.graph.api">Vertex</A>&nbsp;v)</PRE>
<DL>
<DD>Can be overridden in any application where the default choice of
 edges to consider at any vertex is not satisfactory.  The default
 is to consider all edges from a given vertex, directed and undirected.
 Example:  if you want to build an MST on just the undirected
 edges of your graph, you should override this method to read<br>
 <code> return G.incidentEdges( v, EdgeDirection.UNDIR );
 </code>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - Vertex soon to be finished by the algorithm
<DT><B>Returns:</B><DD>All the interesting edges of v -- i.e., all edges whose
 weights you want the algorithm to inspect in considering
 alternative edges to vertices adjacent to v</DL>
</DD>
</DL>
<HR>

<A NAME="destination(jdsl.graph.api.Vertex, jdsl.graph.api.Edge)"><!-- --></A><H3>
destination</H3>
<PRE>
protected <A HREF="../../../jdsl/graph/api/Vertex.html" title="interface in jdsl.graph.api">Vertex</A> <B>destination</B>(<A HREF="../../../jdsl/graph/api/Vertex.html" title="interface in jdsl.graph.api">Vertex</A>&nbsp;origin,
                             <A HREF="../../../jdsl/graph/api/Edge.html" title="interface in jdsl.graph.api">Edge</A>&nbsp;e)</PRE>
<DL>
<DD>Can be overridden to supply the destination of an edge, although I
 can't think of any reason to do so.  Presently implemented with
 opposite(.), so it works even if the edge is incoming to v (see the
 example under incidentEdges(.)).  Called by the core algorithm when
 it is about to finish <code>origin</code> and needs all its
 adjacent vertices.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>origin</CODE> - Vertex soon to be finished by the algorithm<DD><CODE>e</CODE> - Edge incident on <code>origin</code> according to
 incidentEdges(.)
<DT><B>Returns:</B><DD>the vertex opposite <code>origin</code> along
 <code>e</code></DL>
</DD>
</DL>
<HR>

<A NAME="allVertices()"><!-- --></A><H3>
allVertices</H3>
<PRE>
protected <A HREF="../../../jdsl/graph/api/VertexIterator.html" title="interface in jdsl.graph.api">VertexIterator</A> <B>allVertices</B>()</PRE>
<DL>
<DD>Can be overridden to consider a subset of the vertices in the
 graph, although I can't think of any reason to do so.  Note that
 overriding this method will probably also require overriding
 incidentEdges(.), in order to avoid edges leading to vertices not
 in the subset.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>Iterator over all vertices to be initially put in the
 priority queue and eventually finished by the algorithm</DL>
</DD>
</DL>
<HR>

<A NAME="badWeight(jdsl.graph.api.Vertex, jdsl.graph.api.Edge, int)"><!-- --></A><H3>
badWeight</H3>
<PRE>
protected int <B>badWeight</B>(<A HREF="../../../jdsl/graph/api/Vertex.html" title="interface in jdsl.graph.api">Vertex</A>&nbsp;u,
                        <A HREF="../../../jdsl/graph/api/Edge.html" title="interface in jdsl.graph.api">Edge</A>&nbsp;uv,
                        int&nbsp;uvweight)</PRE>
<DL>
<DD>Can be overridden to handle edges that have zero or
 negative weights.  The Prim-Jarnik algorithm is not guaranteed
 to work correctly in the presence of negative-weight edges.
 In the present of zero-weight edges, the algorithm works
 correctly, but some guarantees of other methods of this
 override this method to throw an exception or to fix 
 the problem and return the weight the algorithm should use for
 edge uv.  Whatever weight you return the algorithm will use,
 without checking it.  The default behavior is to throw an
 InvalidEdgeException if uvweight is negative, and to
 return 0 if uvweight is 0 -- that is, to allow zero-weight
 edges.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>u</CODE> - Vertex being finished when the bad weight was
 discovered<DD><CODE>uv</CODE> - Edge for which weight(uv) returned a zero or negative
 value<DD><CODE>uvweight</CODE> - The weight returned from weight(uv)
<DT><B>Returns:</B><DD>Weight the algorithm should use for uv (can be equal to
 uvweight) (the default is to return 0 only if uvweight is 0)
<DT><B>Throws:</B>
<DD><CODE><A HREF="http://java.sun.com/j2se/1.4/docs/api/java/lang/RuntimeException.html" title="class or interface in java.lang">RuntimeException</A></CODE> - Any exception you want to throw to
 indicate a bad weight (the default is to throw an
 InvalidEdgeException only if uvweight is negative)</DL>
</DD>
</DL>
<HR>

<A NAME="init(jdsl.graph.api.InspectableGraph, jdsl.graph.api.Vertex, int)"><!-- --></A><H3>
init</H3>
<PRE>
public void <B>init</B>(<A HREF="../../../jdsl/graph/api/InspectableGraph.html" title="interface in jdsl.graph.api">InspectableGraph</A>&nbsp;g,
                 <A HREF="../../../jdsl/graph/api/Vertex.html" title="interface in jdsl.graph.api">Vertex</A>&nbsp;src,
                 int&nbsp;infinity)</PRE>
<DL>
<DD>Called automatically by executeAll(); must be called by the client
 prior to the first call to doOneIteration() if finer-grained
 control of the algorithm is needed.  The method initializes
 instance variables and then puts all vertices in the PQ with
 initial distances, and records their respective locators.  Can be
 overridden, although I can't think of any reason to do so.
 <p>
 Calls the following methods that can be overridden:  newPQ(),
 initMap(), allVertices(), setLocator(.).
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>g</CODE> - Graph on which to execute the algorithm<DD><CODE>src</CODE> - Vertex at which to root the minimum spanning tree<DD><CODE>infinity</CODE> - Distance with which all other vertices will be
 labelled initially; must be greater than any edge weight</DL>
</DD>
</DL>
<HR>

<A NAME="doOneIteration()"><!-- --></A><H3>
doOneIteration</H3>
<PRE>
public final void <B>doOneIteration</B>()</PRE>
<DL>
<DD>Can be called manually to single-step the
 algorithm, but you must call init(.) before the first call to this
 method.  Finishes one vertex and updates all adjacent
 vertices.  If the vertex that gets finished was reachable from
 the source, this method expands the minimum spanning tree by
 one vertex.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="executeAll(jdsl.graph.api.InspectableGraph, jdsl.graph.api.Vertex, int)"><!-- --></A><H3>
executeAll</H3>
<PRE>
public final void <B>executeAll</B>(<A HREF="../../../jdsl/graph/api/InspectableGraph.html" title="interface in jdsl.graph.api">InspectableGraph</A>&nbsp;g,
                             <A HREF="../../../jdsl/graph/api/Vertex.html" title="interface in jdsl.graph.api">Vertex</A>&nbsp;src,
                             int&nbsp;infinity)</PRE>
<DL>
<DD>The easiest way to use the algorithm is to use this method.
 Calls init(.) once, then doOneIteration() repeatedly until
 either the PQ is empty or shouldContinue() returns false.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="executeAll(jdsl.graph.api.InspectableGraph, jdsl.graph.api.Vertex)"><!-- --></A><H3>
executeAll</H3>
<PRE>
public final void <B>executeAll</B>(<A HREF="../../../jdsl/graph/api/InspectableGraph.html" title="interface in jdsl.graph.api">InspectableGraph</A>&nbsp;g,
                             <A HREF="../../../jdsl/graph/api/Vertex.html" title="interface in jdsl.graph.api">Vertex</A>&nbsp;src)</PRE>
<DL>
<DD>Just like the other version of executeAll(.), but with 
 infinity=Integer.MAX_VALUE
<P>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../jdsl/graph/algo/IntegerDijkstraTemplate.html" title="class in jdsl.graph.algo"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../jdsl/graph/algo/TopologicalSort.html" title="class in jdsl.graph.algo"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="IntegerPrimTemplate.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
